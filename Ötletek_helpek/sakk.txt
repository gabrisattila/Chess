class Tree<T> {

	private T item;
	private int value; // etc.

	private List<Tree<T>> children;

}


class AITree extends Tree<FEN>{}

EDT/gui

{
	final AITree whiteTree; // optional, if white is AI
	final AITree blackTree; // optional, if black is AI

	// stored in GUI, modified by respective AI thread, EDT only passes


	void startAI(){
		new AIThread(whiteTree).start();
	}

}


a
 b
  b1
  b2
 c *
  c1
  c2
   c21
   c22
   c23
  c3
 d

ez lesz a lépés visszaadása után
c
 c1
 c2
  c21
  c22
  c23
 c3

az ellenfél c2-t lépte, akkor onnan folytatjuk

c2
 c21
 c22
 c23

ezt kezdjük mélyebben kiértékelni



(Board x FEN) x Move -> (Board x FEN)


AIState = (Board x FEN)

(board,fen), wqb3 -> update (board, fen)

(board,fen), wqb3 -> withdraw (board, fen)

evalState(FEN) -> int
  b = Board.getInstance().set(FEN)
  children = FEN.children()
  for child: children
     b.set(child)
     ...
  return eval(b)


eval(AITree t)
  for fen: t.leaves
    fen.createSubtree
  bestMove = chooseBestMove(t)
  reduceTree(t,bestMove)
  return bestMove



